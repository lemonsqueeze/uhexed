#!/usr/bin/perl
use Encode qw(decode encode);
use HotKey;

my $end  =   "\e[0m";
my $inv_video = "\e[7m";


binmode STDOUT, ":utf8";
my $file = $ARGV[0];

open(FILE, "+<", $file) || die "couldn't open $file";
#binmode FILE, ':binary';

# Enable unicode input for search ?
my $unicode_mode = 1;

my $encoding = "cp932";   # Windows codepage 932 - Japanese (Shift-JIS)
#my $encoding = "utf-8";
#my $encoding = "utf-16";

# Buffer size
my $bsize = 8192;
my $bytes = "";
my $top = 0;
my $cur = 0;

seek(FILE, 0, 2);
my $file_size = tell(FILE);

sub read_file
{
    sysseek(FILE, $top, 0);
    $bytes = "";
    my $r = sysread(FILE, $bytes, $bsize);
    return ($r != 0);
}

sub write_file
{
    sysseek(FILE, $top, 0);
    my $r = syswrite(FILE, $bytes, $bsize);
    return ($r == $bsize);
}

read_file();

sub to_ascii
{
    my ($c) = @_;
    if (ord($c) >= 32 && ord($c) <= 126)
    {  return $c; }
    return ".";
}

sub to_jap
{
    my ($s) = @_;
    $s = Encode::decode($encoding, $s );    

    my @a = split("", $s);
    for (my $i = 0; $i < @a; $i++)
    {
	if (ord($a[$i]) < 32)
	{  $a[$i] = "."; }
    }	    

    return join("", @a);
}

sub print_chars_jap
{
    my ($i) = @_;

    # ascii/multi-byte characters
    my $line = $i * $width;
    if ($top + $line <= $cur && $cur < $top + $line + $width)	# Highlight character at cursor
    {
	my $off = $line;
	my $split = $cur - ($top + $line);
	my $len = 1;

	# Don't split multi-byte characters !
	if (length(to_jap(substr($bytes, $line, $split))) == 
	    length(to_jap(substr($bytes, $line, $split + 1))))
	{  $len++;   }		# multi-byte char at cursor

	if (($split) &&
	    length(to_jap(substr($bytes, $line, $split))) == 
	    length(to_jap(substr($bytes, $line, $split - 1))))
	{  $len++; $split--;  }	# multi-byte char starts before cursor
	
	my $s = to_jap(substr($bytes, $off, $split));	    
	printf("%s%s", $s, $inv_video);
	$off += $split;
	
	my $s = to_jap(substr($bytes, $off, $len));
	printf("%s%s", $s, $end);
	$off += $len;

	my $s = to_jap(substr($bytes, $off, $width - $len - $split));
	printf("%s", $s);
    }
    else 
    { 
	my $s = to_jap(substr($bytes, $line, $width));
	printf("%s", $s);
    }
}

sub print_chars_ascii
{
    my ($i) = @_;
    
    for (my $j = 0; $j < $width; $j++)
    {
	my $p = $i*$width + $j;
	print("$inv_video") if ($top + $p == $cur);
	printf("%s", to_ascii(substr($bytes, $p, 1)));
	print("$end") if ($top + $p == $cur);
	#printf(" ") if (($j+1) % 4 == 0);		
    }    
}

$width = 28;
$lines = 25;
sub print_page
{
    printf("\n\n\n\n\n\n");

    for (my $i = 0; $i < $lines; $i++)
    {
	printf("0x%08x  ", $top + $i*$width);

	# Regular hex dump
	for (my $j = 0; $j < $width; $j++)
	{
	    my $p = $i*$width + $j;
	    print("$inv_video") if ($top + $p == $cur);
	    printf("%02x", ord(substr($bytes, $p, 1)) );
	    print("$end") if ($top + $p == $cur);
	    printf(" ") if (($j+1) % 4 == 0);		
	}

	printf("    ");
	print_chars_jap($i);
	#print_chars_ascii($i);

	printf("\n");
    }
}

sub read_line_unicode
{
    my ($prompt) = @_;
    print "$prompt";  STDOUT->flush();
    my $s = "";
    while (1)
    {
	my $key = readkey();
	if ($key eq "\n")
	{  return Encode::decode("utf-8", $s);  }
	if (ord($key) == 0x7f)  # Backspace
	{ 
	   my $s2 = $s;  $s2 =~ s/./ /g;
	   printf("\r%s%s", $prompt, Encode::decode("utf-8", $s2));  STDOUT->flush(); 
	   $s = substr($s, 0, length($s)-1); 
	   printf("\r%s%s", $prompt, Encode::decode("utf-8", $s));  STDOUT->flush(); 
	   next;
	}

	printf("\r%s%s", $prompt, Encode::decode("utf-8", $s));  STDOUT->flush(); 
	$s .= $key;
    }
}

sub read_line
{
    my ($prompt) = @_;
    print "$prompt";  STDOUT->flush();
    my $s = "";
    while (1)
    {
	my $key = readkey();
	if ($key eq "\n")
	{  return $s;	}
	if (ord($key) == 0x7f)  # Backspace
	{ 
	   my $s2 = $s;  $s2 =~ s/./ /g;
	   printf("\r%s%s", $prompt, $s2);  STDOUT->flush(); 
	   $s = substr($s, 0, length($s)-1); 
	   printf("\r%s%s", $prompt, $s);  STDOUT->flush(); 
	   next;
	}

	print "$key";  STDOUT->flush();	
	$s .= $key;
    }
}


sub read_key
{
    my $s, $key;
    $key = readkey();   
    $s = $key;
    if ($key eq "\e")
    {
	$key = readkey();
	$s = "Esc$key";
	if ($key eq "[") 
	{
	    $key = readkey();
	    $s .= $key;
	    if ($key eq "5" || $key eq "6") 
	    {
		$key = readkey();
		$s .= $key;
	    }
	}
    }

    $s =~ s/Esc\[D/left/;
    $s =~ s/Esc\[C/right/;
    $s =~ s/Esc\[A/up/;
    $s =~ s/Esc\[B/down/;
    $s =~ s/Esc\[5~/pgup/;
    $s =~ s/Esc\[6~/pgdn/;
    $s =~ s/\n/enter/;

    return $s;
}

print_page();

sub check_up
{
     if ($cur < 0) { $cur = 0; }
     if ($cur < $top)
     {
	 $top -= $lines * $width;
	 if ($top < 0) { $top = 0; }
	 read_file();
     }
}

sub check_down
{
    if ($cur > $top + $lines * $width) 
    {
	$top += $lines * $width;
	read_file();
    }
}


my $last_search = "";
sub search_forward
{
    my ($s) = @_;
    printf("\nsearching for '%s'\n", $s);
    if ($s eq "")
    { return; }

    $last_search = $s;

    # Move to current position
    my $old_top = $top;
    $top = $cur + 1;    read_file();

    my $ubytes;
    $ubytes = ($unicode_mode ? Encode::decode($encoding, $bytes) : $bytes);
    
    while (! ($ubytes =~ m/$s/))
    {  
	$top += $bsize; 
	if (!read_file())      # Not found, go back to starting point
	{  
	    printf("Not found\n");
	    $top = $old_top; read_file(); return; 
	}

	$ubytes = ($unicode_mode ? Encode::decode($encoding, $bytes) : $bytes);
    }
    
    my $i = index($ubytes, $s, 0);
    if ($unicode_mode)  # Find real offset
    {  $i = length(Encode::encode($encoding, substr($ubytes, 0, $i)));  }
    if ($i == -1)
    { printf("Eeek bug, index says not found\n"); }
    else
    {
	printf("Found at 0x%08x\n", $top + $i);
	$cur = $top + $i;
	if ($cur > $top + $lines * $width) 
	{
	    $top = $cur;
	    read_file();   
	}
    }

    # Keep original position if on the same page
    if ($old_top <= $top && $top < $old_top + $lines * $width)
    {  $top = $old_top;  read_file();    }
}

sub write_string
{
    my ($s) = @_;
    my $off = $cur - $top;
    $bytes = (substr($bytes, 0, $off) . $s .
	      substr($bytes, $off + length($s)));
    write_file();
}

sub change_hex
{
    my $s = read_line("Hex: 0x");
    my $c = chr($s);
    write_string($c);
}

while (1)
{
    my $key = read_key();
#    print "\n";
#    printf("key: '%s' 0x%02x\n", $key, ord($key));

    if ($key eq "left")
    {  $cur--; check_up();    }
    if ($key eq "up")
    {  $cur -= $width;  check_up();    }
    if ($key eq "pgup")
    {  $cur -= $lines * $width;  check_up();    }

    if ($key eq "right")
    {  $cur++;  check_down(); }
    if ($key eq "down")
    {  $cur += $width;  check_down(); }
    if ($key eq "pgdn")
    {  $cur += $lines * $width;  check_down();    }

    if ($key eq "<")
    {  $cur = $top = 0; read_file(); }
    if ($key eq ">")
    {
	$cur = $file_size - 1;
	$top = $cur - $lines * $width + 1;
	read_file();
    }
    if ($key eq "")
    {
	$top = $cur - $lines/2 * $width;
	if ($top < 0) { $top = 0; }
	read_file();
    }
    
    if ($key eq "U")
    {  $unicode_mode = !$unicode_mode; printf("Unicode mode: %i\n", $unicode_mode); }
    
    if ($key eq "/")
    {  search_forward(($unicode_mode ? read_line_unicode("/") : read_line("/")));  }
    if ($key eq "n")
    {  search_forward($last_search);  }


    if ($key eq "w")
    {  write_string(read_line("write: "));   }

    if ($key eq "x")
    {  change_hex(); }

    print_page();
}
