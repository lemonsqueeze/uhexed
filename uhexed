#!/usr/bin/perl
use Encode qw(decode encode);
use HotKey;

my $end  =   "\e[0m";
my $inv_video = "\e[7m";


binmode STDOUT, ":utf8";
my $file = $ARGV[0];

open(FILE, "+<", $file) || die "couldn't open $file";
#binmode FILE, ':binary';

# Enable unicode input for search ?
my $unicode_mode = 1;

# Buffer size
my $bsize = 8192;
my $bytes = "";
my $top = 0;
my $cur = 0;

seek(FILE, 0, 2);
my $file_size = tell(FILE);

sub read_file
{
    sysseek(FILE, $top, 0);
    $bytes = "";
    my $r = sysread(FILE, $bytes, $bsize);
    return ($r != 0);
}

sub write_file
{
    sysseek(FILE, $top, 0);
    my $r = syswrite(FILE, $bytes, $bsize);
    return ($r == $bsize);
}

read_file();

sub to_ascii
{
    my ($c) = @_;
    if (ord($c) >= 32 && ord($c) <= 126)
    {  return $c; }
    return ".";
}

sub to_jap
{
    my ($s) = @_;
    $s = Encode::decode("cp932", $s );    

    my @a = split("", $s);
    for (my $i = 0; $i < @a; $i++)
    {
	if (ord($a[$i]) < 32)
	{  $a[$i] = "."; }
    }	    

    return join("", @a);
}

$width = 28;
$lines = 25;
sub print_page
{
    printf("\n\n\n\n\n\n");

    for (my $i = 0; $i < $lines; $i++)
    {
	printf("0x%08x  ", $top + $i*$width);

	# Regular hex dump
	for (my $j = 0; $j < $width; $j++)
	{
	    my $p = $i*$width + $j;
	    print("$inv_video") if ($top + $p == $cur);
	    printf("%02x", ord(substr($bytes, $p, 1)) );
	    print("$end") if ($top + $p == $cur);
	    printf(" ") if (($j+1) % 4 == 0);		
	}

	# ascii/multi-byte characters
	printf("    ");
	my $line = $i * $width;
	if ($top + $line <= $cur && $cur < $top + $line + $width)	# Highlight character at cursor
	{
	    my $off = $line;
	    my $split = $cur - ($top + $line);
	    my $len = 1;

	    # Don't split multi-byte characters !
	    if (length(to_jap(substr($bytes, $line, $split))) == 
		length(to_jap(substr($bytes, $line, $split + 1))))
	    {  $len++;   }		# multi-byte char at cursor

	    if (($split) &&
		length(to_jap(substr($bytes, $line, $split))) == 
		length(to_jap(substr($bytes, $line, $split - 1))))
	    {  $len++; $split--;  }	# multi-byte char starts before cursor
	    
	    my $s = to_jap(substr($bytes, $off, $split));	    
	    printf("%s%s", $s, $inv_video);
	    $off += $split;
	    
	    my $s = to_jap(substr($bytes, $off, $len));
	    printf("%s%s", $s, $end);
	    $off += $len;

	    my $s = to_jap(substr($bytes, $off, $width - $len - $split));
	    printf("%s", $s);
	}
	else 
	{ 
	    my $s = to_jap(substr($bytes, $line, $width));
	    printf("%s", $s);
	}
	printf("\n");
    }
}

sub read_line_unicode
{
    my ($prompt) = @_;
    print "$prompt";  STDOUT->flush();
    my $s = "";
    while (1)
    {
	my $key = readkey();
	if ($key eq "\n")
	{  return Encode::decode("utf-8", $s);  }
	if (ord($key) == 0x7f)  # Backspace
	{ 
	   my $s2 = $s;  $s2 =~ s/./ /g;
	   printf("\r%s%s", $prompt, Encode::decode("utf-8", $s2));  STDOUT->flush(); 
	   $s = substr($s, 0, length($s)-1); 
	   printf("\r%s%s", $prompt, Encode::decode("utf-8", $s));  STDOUT->flush(); 
	   next;
	}

	printf("\r%s%s", $prompt, Encode::decode("utf-8", $s));  STDOUT->flush(); 
	$s .= $key;
    }
}

sub read_line
{
    my ($prompt) = @_;
    print "$prompt";  STDOUT->flush();
    my $s = "";
    while (1)
    {
	my $key = readkey();
	if ($key eq "\n")
	{  return $s;	}
	if (ord($key) == 0x7f)  # Backspace
	{ 
	   my $s2 = $s;  $s2 =~ s/./ /g;
	   printf("\r%s%s", $prompt, $s2);  STDOUT->flush(); 
	   $s = substr($s, 0, length($s)-1); 
	   printf("\r%s%s", $prompt, $s);  STDOUT->flush(); 
	   next;
	}

	print "$key";  STDOUT->flush();	
	$s .= $key;
    }
}


sub read_key
{
    my $s, $key;
    $key = readkey();   
    $s = $key;
    if ($key eq "\e")
    {
	$key = readkey();
	$s = "Esc$key";
	if ($key eq "[") 
	{
	    $key = readkey();
	    $s .= $key;
	    if ($key eq "5" || $key eq "6") 
	    {
		$key = readkey();
		$s .= $key;
	    }
	}
    }

    $s =~ s/Esc\[D/left/;
    $s =~ s/Esc\[C/right/;
    $s =~ s/Esc\[A/up/;
    $s =~ s/Esc\[B/down/;
    $s =~ s/Esc\[5~/pgup/;
    $s =~ s/Esc\[6~/pgdn/;
    $s =~ s/\n/enter/;

    return $s;
}

print_page();

sub check_up
{
     if ($cur < 0) { $cur = 0; }
     if ($cur < $top)
     {
	 $top -= $lines * $width;
	 if ($top < 0) { $top = 0; }
	 read_file();
     }
}

sub check_down
{
    if ($cur > $top + $lines * $width) 
    {
	$top += $lines * $width;
	read_file();
    }
}

sub search_forward
{
    my ($s) = @_;
    printf("\nsearching for '%s'\n", $s);
    if ($s eq "")
    { return; }

    # Move to current position
    my $old_top = $top;
    $top = $cur + 1;    read_file();

    my $ubytes;
    $ubytes = ($unicode_mode ? Encode::decode("cp932", $bytes) : $bytes);
    
    while (! ($ubytes =~ m/$s/))
    {  
	$top += $bsize; 
	if (!read_file())      # Not found, go back to starting point
	{  
	    printf("Not found\n");
	    $top = $old_top; read_file(); return; 
	}

	$ubytes = ($unicode_mode ? Encode::decode("cp932", $bytes) : $bytes);
    }
    
    my $i = index($ubytes, $s, 0);
    if ($unicode_mode)  # Find real offset
    {  $i = length(Encode::encode("cp932", substr($ubytes, 0, $i)));  }
    if ($i == -1)
    { printf("Eeek bug, index says not found\n"); }
    else
    {
	printf("Found at 0x%08x\n", $top + $i);
	$cur = $top + $i;
	if ($cur > $top + $lines * $width) 
	{
	    $top = $cur;
	    read_file();   
	}
    }

    # Keep original position if on the same page
    if ($old_top <= $top && $top < $old_top + $lines * $width)
    {  $top = $old_top;  read_file();    }
}

sub write_string
{
    my ($s) = @_;
    my $off = $cur - $top;
    $bytes = (substr($bytes, 0, $off) . $s .
	      substr($bytes, $off + length($s)));
    write_file();
}

sub change_hex
{
    my $s = read_line("Hex: 0x");
    my $c = chr($s);
    write_string($c);
}

while (1)
{
    my $key = read_key();
#    print "\n";
#    printf("key: '%s' 0x%02x\n", $key, ord($key));

    if ($key eq "left")
    {  $cur--; check_up();    }
    if ($key eq "up")
    {  $cur -= $width;  check_up();    }
    if ($key eq "pgup")
    {  $cur -= $lines * $width;  check_up();    }

    if ($key eq "right")
    {  $cur++;  check_down(); }
    if ($key eq "down")
    {  $cur += $width;  check_down(); }
    if ($key eq "pgdn")
    {  $cur += $lines * $width;  check_down();    }

    if ($key eq "<")
    {  $cur = $top = 0; read_file(); }
    if ($key eq ">")
    {
	$cur = $file_size - 1;
	$top = $cur - $lines * $width + 1;
	read_file();
    }
    if ($key eq "")
    {
	$top = $cur - $lines/2 * $width;
	if ($top < 0) { $top = 0; }
	read_file();
    }
    
    if ($key eq "U")
    {  $unicode_mode = !$unicode_mode; printf("Unicode mode: %i\n", $unicode_mode); }
    
    if ($key eq "/")
    {  search_forward(($unicode_mode ? read_line_unicode("/") : read_line("/")));  }

    if ($key eq "w")
    {  write_string(read_line("write: "));   }

    if ($key eq "x")
    {  change_hex(); }

    print_page();
}
