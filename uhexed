#!/usr/bin/perl
use Encode qw(decode encode);
use HotKey;

#my $encoding = "cp932";   # Windows codepage 932 - Japanese Shift-JIS
my $encoding = "utf-8";
#my $encoding = "utf-16le";
#my $encoding = "ascii";

#my $paint = "dumb";       # debugging
my $paint = "term";


if ($ARGV[0] eq "-e")
{  shift @ARGV; $encoding = $ARGV[0]; shift @ARGV; }
my $encoding_last = $encoding;

######################################################################

# Enable unicode input for search ?
my $search_mode = "unicode";


# Terminal stuff
my $tcols = `tput cols`;
my $tlines = `tput lines`;
my $blank = join("", map { " " } (1..$tcols) );
my $bl = $blank . "\n";		# blank line
my $clear_screen = 0;

my $end  =   "\e[0m";
my $inv_video = "\e[7m";
my $cls = "\e[2J";
my $cursor_top = "\e[0;0H";	# ESC[y;xH  move cursor to row y, col x


binmode STDOUT, ":utf8";
my $file = $ARGV[0];

# TODO read-only mode
open(FILE, "+<", $file) || die "couldn't open $file";


# Buffer size
my $bsize = 8192;
my $bytes = "";
my $top = 0;
my $cur = 0;

my $status = "";

seek(FILE, 0, 2);
my $file_size = tell(FILE);

sub read_file
{
    sysseek(FILE, $top, 0);
    $bytes = "";
    my $r = sysread(FILE, $bytes, $bsize);
    $clear_screen = 1;
    return ($r != 0);
}

sub write_file
{
    sysseek(FILE, $top, 0);
    my $r = syswrite(FILE, $bytes, $bsize);
    return ($r == $bsize);
}

sub to_ascii
{
    my ($c) = @_;
    if (ord($c) >= 32 && ord($c) <= 126)
    {  return $c; }
    return ".";
}

sub to_multibyte
{
    my ($s) = @_;
    $s = Encode::decode($encoding, $s );    

    my @a = split("", $s);
    for (my $i = 0; $i < @a; $i++)
    {
	if (ord($a[$i]) < 32)
	{  $a[$i] = "."; }
    }

    $s = join("", @a);
    # Remove control characters
    $s =~ s/\p{C}/./g;    # \p{C} more generic than \p{Control} 
    return $s;
}

sub print_chars_multibyte
{
    my ($i) = @_;

    # ascii/multi-byte characters
    my $line = $i * $width;
    if ($top + $line <= $cur && $cur < $top + $line + $width)	# Highlight character at cursor
    {
	my $off = $line;
	my $split = $cur - ($top + $line);
	my $len = 1;

	# Don't split multi-byte characters !
	if (length(to_multibyte(substr($bytes, $line, $split))) == 
	    length(to_multibyte(substr($bytes, $line, $split + 1))))
	{  $len++;   }		# multi-byte char at cursor

	if (($split) &&
	    length(to_multibyte(substr($bytes, $line, $split))) == 
	    length(to_multibyte(substr($bytes, $line, $split - 1))))
	{  $len++; $split--;  }	# multi-byte char starts before cursor
	
	my $s = to_multibyte(substr($bytes, $off, $split));	    
	printf("%s%s", $s, $inv_video);
	$off += $split;
	
	my $s = to_multibyte(substr($bytes, $off, $len));
	printf("%s%s", $s, $end);
	$off += $len;

	my $s = to_multibyte(substr($bytes, $off, $width - $len - $split));
	printf("%s", $s);
    }
    else 
    { 
	my $s = to_multibyte(substr($bytes, $line, $width));
	printf("%s", $s);
    }
}

sub print_chars_ascii
{
    my ($i) = @_;
    
    for (my $j = 0; $j < $width; $j++)
    {
	my $p = $i*$width + $j;
	print("$inv_video") if ($top + $p == $cur);
	printf("%s", to_ascii(substr($bytes, $p, 1)));
	print("$end") if ($top + $p == $cur);
	#printf(" ") if (($j+1) % 4 == 0);		
    }    
}

sub clear_line
{
    print "\r$blank\r";  STDOUT->flush();
}

$width = 28;
$lines = 25;
sub print_page
{    
    if ($paint eq "term")
    {	print "$cursor_top";   }

    # Status line
    clear_line();
    printf("%s", ($status ne "" ? $status : "\n"));
    $status = "";

    print "$bl$bl$bl$bl";

    clear_line();
    printf("%-11s ($encoding)\n", sprintf("(%i%%)", $top * 100 / $file_size));

    for (my $i = 0; $i < $lines; $i++)
    {
	if ($clear_screen) { clear_line(); }
	printf("0x%08x  ", $top + $i*$width);

	# Regular hex dump
	for (my $j = 0; $j < $width; $j++)
	{
	    my $p = $i*$width + $j;
	    print("$inv_video") if ($top + $p == $cur);
	    printf("%02x", ord(substr($bytes, $p, 1)) );
	    print("$end") if ($top + $p == $cur);
	    printf(" ") if (($j+1) % 4 == 0);		
	}

	printf("    ");
	if ($encoding eq "ascii")
	{   print_chars_ascii($i);  }
	else
	{   print_chars_multibyte($i);    }
	
	printf("  \n");
    }

    print "$bl";
    $clear_screen = 0;
}

sub read_line_unicode
{
    my ($prompt) = @_;
    print "$prompt";  STDOUT->flush();
    my $s = "";
    while (1)
    {
	my $key = readkey();
	if ($key eq "\n")
	{  clear_line(); return Encode::decode("utf-8", $s);  }
	if (ord($key) == 0x7f)  # Backspace
	{ 
	   my $s2 = $s;  $s2 =~ s/./ /g;
	   printf("\r%s%s", $prompt, Encode::decode("utf-8", $s2));  STDOUT->flush(); 
	   $s = substr($s, 0, length($s)-1); 
	   printf("\r%s%s", $prompt, Encode::decode("utf-8", $s));  STDOUT->flush(); 
	   next;
	}

	printf("\r%s%s", $prompt, Encode::decode("utf-8", $s));  STDOUT->flush(); 
	$s .= $key;
    }
}

sub read_line
{
    my ($prompt) = @_;
    print "$prompt";  STDOUT->flush();
    my $s = "";
    while (1)
    {
	my $key = readkey();
	if ($key eq "\n")
	{  clear_line(); return $s;	}
	if (ord($key) == 0x7f)  # Backspace
	{ 
	   my $s2 = $s;  $s2 =~ s/./ /g;
	   printf("\r%s%s", $prompt, $s2);  STDOUT->flush(); 
	   $s = substr($s, 0, length($s)-1); 
	   printf("\r%s%s", $prompt, $s);  STDOUT->flush(); 
	   next;
	}

	print "$key";  STDOUT->flush();	
	$s .= $key;
    }
}


sub read_key
{
    my $s, $key;
    $key = readkey();  $s = $key;
    if ($key eq "\e")
    {
	$key = readkey();  $s = "Esc$key";
	if ($key eq "[") 
	{
	    $key = readkey();  $s .= $key;
	    if ($key eq "5" || $key eq "6") 
	    {
		$key = readkey();  $s .= $key;
		if ($key eq ";")
		{
		    $key = readkey();  $s .= $key;
		    $key = readkey();  $s .= $key;
		}
	    }
	}
    }

    $s =~ s/Esc\[D/left/;
    $s =~ s/Esc\[C/right/;
    $s =~ s/Esc\[A/up/;
    $s =~ s/Esc\[B/down/;
    $s =~ s/Esc\[5~/pgup/;
    $s =~ s/Esc\[6~/pgdn/;
    $s =~ s/Esc\[5;5~/ctrl_pgup/;
    $s =~ s/Esc\[6;5~/ctrl_pgdn/;
    $s =~ s/\n/enter/;

    return $s;
}

sub check_up
{
     if ($cur < 0) { $cur = 0; }
     if ($cur < $top)
     {
	 $top -= $lines * $width;
	 if ($top < 0) { $top = 0; }
	 read_file();
     }
}

sub check_down
{
    if ($cur >= $top + $lines * $width) 
    {
	$top += $lines * $width;
	read_file();
    }
}

sub search_decode
{
    my ($s) = @_;
    
    if ($search_mode eq "unicode")
    {  return  Encode::decode($encoding, $s);  }
    if ($search_mode eq "hex")
    {  return  unpack("H*", $s);  }
    return $s;
}

sub search_encode
{
    my ($s) = @_;
    
    if ($search_mode eq "unicode")
    {  return  Encode::encode($encoding, $s);  }
    if ($search_mode eq "hex")
    {  return  pack("H*", $s);  }
    return $s;
}

sub sequence_index
{   
    my ($s) = @_;
    my $b;
    
    if (found_sequence($s) == 2)
    {  $b = search_decode(substr($bytes, 1));    }
    else
    {  $b = search_decode($bytes);    }
    
    my $i = index($b, $s, 0);
    if ($search_mode ne "ascii" && $i != -1)  # Find offset in bytes
    {  $i = length(search_encode(substr($b, 0, $i))) + (found_sequence($s) == 2);  }
    return $i;
}


sub found_sequence
{   
    my ($s) = @_;
    
    if ($search_mode eq "ascii")
    {  return ($bytes =~ m/$s/); }

    if ($search_mode eq "hex")
    {  return (search_decode($bytes) =~ m/$s/);   }
    
    # $search_mode: "unicode"
    if (search_decode($bytes) =~ m/$s/)
    {  return 1;  }

    # Try shifting by one byte (needed for utf-16)
    if (search_decode(substr($bytes, 1)) =~ m/$s/)
    {  return 2;  }

    return 0;
}


my $last_search = "";
sub search_forward
{
    my ($s) = @_;
    #printf("\nsearching for '%s'\n", $s);
    if ($s eq "")
    { return; }

    $last_search = $s;

    # Move to current position
    my $old_top = $top;
    $top = $cur + 1;    read_file();

    while (!found_sequence($s))
    {  
	$top += $bsize; 
	if (!read_file())      # Not found, go back to starting point
	{  
	    $status = sprintf("'%s' not found\n", $s);
	    $top = $old_top; read_file(); return; 
	}
    }
    
    my $i = sequence_index($s);
    if ($i == -1)
    { die("Eeek bug, index says not found\n"); }
    else
    {
	$status = sprintf("Found at 0x%08x\n", $top + $i);
	$cur = $top + $i;
	if ($cur > $top + $lines * $width) 
	{
	    $top = $cur;  $top -= $top % 2;
	    read_file();   
	}
    }

    # Keep original position if on the same page
    if ($old_top <= $top && $top < $old_top + $lines * $width)
    {  $top = $old_top;  read_file();    }
}

sub write_string
{
    my ($s) = @_;
    my $off = $cur - $top;
    $bytes = (substr($bytes, 0, $off) . $s .
	      substr($bytes, $off + length($s)));
    write_file();
}

sub change_hex
{
    my $s = read_line("Hex: 0x");
    my $c = chr($s);
    write_string($c);
}

sub goto_address
{
    my $s = read_line("Goto address: 0x");
    if ($s eq "") { return; }
    $s = eval("0x$s");
    $cur = $top = $s; read_file();
}

#####################################################################


# Clear screen
if ($paint eq "term") { print($cls); }

read_file();
print_page();


while (1)
{
    my $key = read_key();
#    print "\n";
#    printf("key: '%s' 0x%02x\n", $key, ord($key));

    # Move commands
    if ($key eq "left" || $key eq "")
    {  $cur--; check_up();    }
    if ($key eq "up" || $key eq "")
    {  $cur -= $width;  check_up();    }
    if ($key eq "pgup" || $key eq "Escv")
    {  $cur -= $lines * $width;  check_up();    }

    if ($key eq "right" || $key eq "")
    {  $cur++;  check_down(); }
    if ($key eq "down" || $key eq "")
    {  $cur += $width;  check_down(); }
    if ($key eq "pgdn" || $key eq "")
    {  $cur += $lines * $width;  check_down();    }

    if ($key eq "ctrl_pgdn")
    {  $top += int($file_size / 100); $top += $top % 2;  $cur = $top; read_file(); }
    if ($key eq "ctrl_pgup")
    {  $top -= int($file_size / 100); $top += $top % 2;  if ($top < 0) { $top = 0; } $cur = $top; read_file(); }

    if ($key eq "<")
    {  $cur = $top = 0; read_file(); }
    if ($key eq ">")
    {  $cur = $file_size - 1;	$top = $cur - $lines * $width + 1; read_file();   }

    if ($key eq "g")
    {  goto_address(); }

    # Display commands
    if ($key eq "a")
    {  $encoding = ($encoding eq "ascii" ? $encoding_last : "ascii");  read_file();  }
    if ($key eq "")
    {  $top = $cur - $lines/2 * $width; if ($top < 0) { $top = 0; }  read_file(); print "$cls";   }

    # Search commands
    if ($key eq "/")
    { 
	my $prompt = ($search_mode eq "hex" ? "/ 0x" : "/");
	search_forward(($search_mode eq "unicode" ? read_line_unicode($prompt) : read_line($prompt)));  
    }
    if ($key eq "n")
    {  search_forward($last_search);  }

    if ($key eq "U")
    {  $search_mode = ($search_mode eq "unicode" ? "ascii" : "unicode");
       $status = sprintf("Search mode: %s\n", $search_mode);    }
    if ($key eq "X")
    {  $search_mode = "hex";  $status = sprintf("Search mode: %s\n", $search_mode);  }

    # Write operations
    if ($key eq "w")
    {  write_string(read_line("write: "));   }

    if ($key eq "x")
    {  change_hex(); }

    if ($key eq "q")
    {  exit 0;  }


    print_page();
}
